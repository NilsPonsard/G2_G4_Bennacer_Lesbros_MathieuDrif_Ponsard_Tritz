\href{https://npmjs.org/package/bytes}{\texttt{ }} \href{https://npmjs.org/package/bytes}{\texttt{ }} \href{https://travis-ci.org/visionmedia/bytes.js}{\texttt{ }} \href{https://coveralls.io/r/visionmedia/bytes.js?branch=master}{\texttt{ }}

Utility to parse a string bytes (ex\+: {\ttfamily 1TB}) to bytes ({\ttfamily 1099511627776}) and vice-\/versa.\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md219}{}\doxysection{Installation}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md219}
This is a \href{https://nodejs.org/en/}{\texttt{ Node.\+js}} module available through the \href{https://www.npmjs.com/}{\texttt{ npm registry}}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\texttt{ {\ttfamily npm install} command}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ npm install bytes}
\end{DoxyCode}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md220}{}\doxysection{Usage}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md220}

\begin{DoxyCode}{0}
\DoxyCodeLine{var bytes = require('bytes');}
\end{DoxyCode}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md221}{}\doxysubsubsection{bytes.\+format(number value, \mbox{[}options\mbox{]})\+: string｜null}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md221}
Format the given value in bytes into a string. If the value is negative, it is kept as such. If it is a float, it is rounded.

{\bfseries{Arguments}}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endhead
value &{\ttfamily number} &Value in bytes  \\\cline{1-3}
options &{\ttfamily Object} &Conversion options  \\\cline{1-3}
\end{longtabu}


{\bfseries{Options}}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Property }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Property }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endhead
decimal\+Places &{\ttfamily number}｜{\ttfamily null} &Maximum number of decimal places to include in output. Default value to {\ttfamily 2}.  \\\cline{1-3}
fixed\+Decimals &{\ttfamily boolean}｜{\ttfamily null} &Whether to always display the maximum number of decimal places. Default value to {\ttfamily false}  \\\cline{1-3}
thousands\+Separator &{\ttfamily string}｜{\ttfamily null} &Example of values\+: `' \textquotesingle{}{\ttfamily ,}\textquotesingle{},\textquotesingle{}{\ttfamily and}.{\ttfamily ... Default value to}\textquotesingle{}\textquotesingle{}{\ttfamily .$<$/td$>$ $<$/tr$>$ $<$tr class=\char`\"{}markdown\+Table\+Row\+Even\char`\"{}$>$ $<$td class=\char`\"{}markdown\+Table\+Body\+None\char`\"{}$>$ unit$<$/td$>$ $<$td class=\char`\"{}markdown\+Table\+Body\+None\char`\"{}$>$}string{\ttfamily ｜}null{\ttfamily $<$/td$>$ $<$td class=\char`\"{}markdown\+Table\+Body\+None\char`\"{}$>$ The unit in which the result will be returned (B/\+K\+B/\+M\+B/\+G\+B/\+TB). Default value to}\textquotesingle{}\textquotesingle{}{\ttfamily (which means auto detect).$<$/td$>$ $<$/tr$>$ $<$tr class=\char`\"{}markdown\+Table\+Row\+Odd\char`\"{}$>$ $<$td class=\char`\"{}markdown\+Table\+Body\+None\char`\"{}$>$ unit\+Separator$<$/td$>$ $<$td class=\char`\"{}markdown\+Table\+Body\+None\char`\"{}$>$}string{\ttfamily ｜}null{\ttfamily $<$/td$>$ $<$td class=\char`\"{}markdown\+Table\+Body\+None\char`\"{}$>$ Separator to use between number and unit. Default value to}\textquotesingle{}\textquotesingle{}\`{}.  \\\cline{1-3}
\end{longtabu}


{\bfseries{Returns}}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endhead
results &{\ttfamily string}｜{\ttfamily null} &Return null upon error. String value otherwise.  \\\cline{1-3}
\end{longtabu}


{\bfseries{Example}}


\begin{DoxyCode}{0}
\DoxyCodeLine{bytes(1024);}
\DoxyCodeLine{// output: '1KB'}
\DoxyCodeLine{}
\DoxyCodeLine{bytes(1000);}
\DoxyCodeLine{// output: '1000B'}
\DoxyCodeLine{}
\DoxyCodeLine{bytes(1000, \{thousandsSeparator: ' '\});}
\DoxyCodeLine{// output: '1 000B'}
\DoxyCodeLine{}
\DoxyCodeLine{bytes(1024 * 1.7, \{decimalPlaces: 0\});}
\DoxyCodeLine{// output: '2KB'}
\DoxyCodeLine{}
\DoxyCodeLine{bytes(1024, \{unitSeparator: ' '\});}
\DoxyCodeLine{// output: '1 KB'}
\end{DoxyCode}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md222}{}\doxysubsubsection{bytes.\+parse(string｜number value)\+: number｜null}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md222}
Parse the string value into an integer in bytes. If no unit is given, or {\ttfamily value} is a number, it is assumed the value is in bytes.

Supported units and abbreviations are as follows and are case-\/insensitive\+:


\begin{DoxyItemize}
\item {\ttfamily b} for bytes
\item {\ttfamily kb} for kilobytes
\item {\ttfamily mb} for megabytes
\item {\ttfamily gb} for gigabytes
\item {\ttfamily tb} for terabytes
\end{DoxyItemize}

The units are in powers of two, not ten. This means 1kb = 1024b according to this parser.

{\bfseries{Arguments}}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endhead
value &{\ttfamily string}｜{\ttfamily number} &String to parse, or number in bytes.  \\\cline{1-3}
\end{longtabu}


{\bfseries{Returns}}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description  }\\\cline{1-3}
\endhead
results &{\ttfamily number}｜{\ttfamily null} &Return null upon error. Value in bytes otherwise.  \\\cline{1-3}
\end{longtabu}


{\bfseries{Example}}


\begin{DoxyCode}{0}
\DoxyCodeLine{bytes('1KB');}
\DoxyCodeLine{// output: 1024}
\DoxyCodeLine{}
\DoxyCodeLine{bytes('1024');}
\DoxyCodeLine{// output: 1024}
\DoxyCodeLine{}
\DoxyCodeLine{bytes(1024);}
\DoxyCodeLine{// output: 1024}
\end{DoxyCode}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md223}{}\doxysection{License}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_bytes__readme_autotoc_md223}
\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 