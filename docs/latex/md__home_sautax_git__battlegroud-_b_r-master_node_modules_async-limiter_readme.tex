A module for limiting concurrent asynchronous actions in flight. Forked from \href{https://github.com/jessetane/queue}{\texttt{ queue}}.

\href{http://www.npmjs.org/async-limiter}{\texttt{ }} \href{https://travis-ci.org/STRML/async-limiter}{\texttt{ }} \href{https://coveralls.io/r/STRML/async-limiter}{\texttt{ }}

This module exports a class {\ttfamily Limiter} that implements some of the {\ttfamily Array} A\+PI. Pass async functions (ones that accept a callback or return a promise) to an instance\textquotesingle{}s additive array methods.\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md63}{}\doxysection{Motivation}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md63}
Certain functions, like {\ttfamily zlib}, have \href{https://github.com/nodejs/node/issues/8871\#issuecomment-250915913}{\texttt{ undesirable behavior}} when run at infinite concurrency.

In this case, it is actually faster, and takes far less memory, to limit concurrency.

This module should do the absolute minimum work necessary to queue up functions. P\+Rs are welcome that would make this module faster or lighter, but new functionality is not desired.

Style should confirm to nodejs/node style.\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md64}{}\doxysection{Example}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md64}

\begin{DoxyCode}{0}
\DoxyCodeLine{var Limiter = require('async-\/limiter')}
\DoxyCodeLine{}
\DoxyCodeLine{var t = new Limiter(\{concurrency: 2\});}
\DoxyCodeLine{var results = []}
\DoxyCodeLine{}
\DoxyCodeLine{// add jobs using the familiar Array API}
\DoxyCodeLine{t.push(function (cb) \{}
\DoxyCodeLine{  results.push('two')}
\DoxyCodeLine{  cb()}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{t.push(}
\DoxyCodeLine{  function (cb) \{}
\DoxyCodeLine{    results.push('four')}
\DoxyCodeLine{    cb()}
\DoxyCodeLine{  \},}
\DoxyCodeLine{  function (cb) \{}
\DoxyCodeLine{    results.push('five')}
\DoxyCodeLine{    cb()}
\DoxyCodeLine{  \}}
\DoxyCodeLine{)}
\DoxyCodeLine{}
\DoxyCodeLine{t.unshift(function (cb) \{}
\DoxyCodeLine{  results.push('one')}
\DoxyCodeLine{  cb()}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{t.splice(2, 0, function (cb) \{}
\DoxyCodeLine{  results.push('three')}
\DoxyCodeLine{  cb()}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{// Jobs run automatically. If you want a callback when all are done,}
\DoxyCodeLine{// call 'onDone()'.}
\DoxyCodeLine{t.onDone(function () \{}
\DoxyCodeLine{  console.log('all done:', results)}
\DoxyCodeLine{\})}
\end{DoxyCode}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md65}{}\doxysection{Zlib Example}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md65}

\begin{DoxyCode}{0}
\DoxyCodeLine{const zlib = require('zlib');}
\DoxyCodeLine{const Limiter = require('async-\/limiter');}
\DoxyCodeLine{}
\DoxyCodeLine{const message = \{some: "data"\};}
\DoxyCodeLine{const payload = new Buffer(JSON.stringify(message));}
\DoxyCodeLine{}
\DoxyCodeLine{// Try with different concurrency values to see how this actually}
\DoxyCodeLine{// slows significantly with higher concurrency!}
\DoxyCodeLine{//}
\DoxyCodeLine{// 5:        1398.607ms}
\DoxyCodeLine{// 10:       1375.668ms}
\DoxyCodeLine{// Infinity: 4423.300ms}
\DoxyCodeLine{//}
\DoxyCodeLine{const t = new Limiter(\{concurrency: 5\});}
\DoxyCodeLine{function deflate(payload, cb) \{}
\DoxyCodeLine{  t.push(function(done) \{}
\DoxyCodeLine{    zlib.deflate(payload, function(err, buffer) \{}
\DoxyCodeLine{      done();}
\DoxyCodeLine{      cb(err, buffer);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{  \});}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{console.time('deflate');}
\DoxyCodeLine{for(let i = 0; i < 30000; ++i) \{}
\DoxyCodeLine{  deflate(payload, function (err, buffer) \{\});}
\DoxyCodeLine{\}}
\DoxyCodeLine{q.onDone(function() \{}
\DoxyCodeLine{  console.timeEnd('deflate');}
\DoxyCodeLine{\});}
\end{DoxyCode}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md66}{}\doxysection{Install}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md66}
{\ttfamily npm install async-\/limiter}\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md67}{}\doxysection{Test}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md67}
{\ttfamily npm test}\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md68}{}\doxysection{A\+PI}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md68}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md69}{}\doxysubsection{$<$tt$>$var t = new Limiter(\mbox{[}opts\mbox{]})$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md69}
Constructor. {\ttfamily opts} may contain inital values for\+:
\begin{DoxyItemize}
\item {\ttfamily q.\+concurrency}
\end{DoxyItemize}\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md70}{}\doxysection{Instance methods}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md70}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md71}{}\doxysubsection{$<$tt$>$q.\+on\+Done(fn)$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md71}
{\ttfamily fn} will be called once and only once, when the queue is empty.\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md72}{}\doxysection{Instance methods mixed in from $<$tt$>$\+Array$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md72}
Mozilla has docs on how these methods work \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array}{\texttt{ here}}. \hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md73}{}\doxysubsection{$<$tt$>$q.\+push(element1, ..., element\+N)$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md73}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md74}{}\doxysubsection{$<$tt$>$q.\+unshift(element1, ..., element\+N)$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md74}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md75}{}\doxysubsection{$<$tt$>$q.\+splice(index , how\+Many\mbox{[}, element1\mbox{[}, ...\mbox{[}, element\+N\mbox{]}\mbox{]}\mbox{]})$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md75}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md76}{}\doxysection{Properties}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md76}
\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md77}{}\doxysubsection{$<$tt$>$q.\+concurrency$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md77}
Max number of jobs the queue should process concurrently, defaults to {\ttfamily Infinity}.\hypertarget{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md78}{}\doxysubsection{$<$tt$>$q.\+length$<$/tt$>$}\label{md__home_sautax_git__battlegroud-_b_r-master_node_modules_async-limiter_readme_autotoc_md78}
Jobs pending + jobs to process (readonly). 